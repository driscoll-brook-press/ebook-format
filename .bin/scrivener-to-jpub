#!/usr/bin/env ruby

require 'nokogiri'
require 'optparse'
require 'ostruct'
require 'pathname'
require 'yaml'

class CommandLine
  def self.parse
    options = {}

    parser = OptionParser.new do |opts|
      opts.banner << ' file dir'

      opts.on_tail('-h', '--help', 'print this message') do
        puts opts
        exit
      end
    end

    parser.parse! ARGV

    unless ARGV.length == 2
      puts parser
      exit
    end

    options[:scrivener_file] = Pathname(ARGV[0])
    options[:book_dir] = Pathname(ARGV[1])

    unless options[:scrivener_file].directory?
      puts "No such Scrivener file: #{options.scrivener_file}"
      exit
    end

    options
  end
end

class Document
  attr_reader :id, :path

  def initialize(node:, parent_path:, position:)
    @id = node['ID'].to_i
    @title = node.at_xpath('./Title').content
    @type = node['Type']
    slug = @title.gsub(/\s+/, '-').gsub(/[^[:alnum:]-]/, '').downcase
    @path = parent_path / slug
    @custom_metadata = custom_metadata(node)
    @position = position
  end

  def header
    {
      'id' => @id,
      'title' => @title,
      'type' => @type,
      'depth' => @path.to_s.split('/').size,
      'position' => @position
    }.merge(@custom_metadata)
  end

  private

  def custom_metadata(node)
    node.xpath('./MetaData/CustomMetaData/MetaDataItem').inject({}) do |fields, field|
      id = field.at_xpath('./FieldID').content
      value = field.at_xpath('./Value').content
      fields[id] = value
      fields
    end
  end
end

class ScrivenerToMarkdown
  def initialize(scrivener)
    @scrivener = scrivener
    @docs = @scrivener.path / 'Files' / 'Docs'
  end

  def write_to(dir)
    @scrivener.documents.each { |document| write(dir: dir, document: document) }
  end

  def write(dir:, document:)
    md_path = dir / "#{document.path}.md"
    md_path.parent.mkpath

    content = StringIO.new
    content.puts document.header.to_yaml
    content.puts '---'
    rtf_path = rtf_path(document)
    content.puts to_markdown(rtf_path) if rtf_path.file?
    md_path.write(content.string)
  end

  def to_markdown(rtf_path)
    %x{ textutil -convert html -excludedelements '(span)' -strip -stdout #{rtf_path} | pandoc -f html -t markdown }
  end

  def rtf_path(document)
    @docs / "#{document.id}.rtf"
  end
end

class Scrivener
  attr_reader :documents, :path
  def initialize(path)
    @path = Pathname(path)
    basename = path.basename
    scrivx_path = path / basename.sub_ext('.scrivx')
    raise "Cannot read SCRIVX file: #{scrivx_path}" unless scrivx_path.exist?
    scrivx_file = scrivx_path.open
    scrivx = Nokogiri::XML(scrivx_file)

    @metadata_fields = scrivx.xpath('.//CustomMetaDataSettings/MetaDataField').inject({}) do |fields, field|
      fields[field['ID']] = field.content
      fields
    end

    root = OpenStruct.new 'path' => Pathname.new('')
    @documents = []
    gather_documents(documents: @documents, parent_node: scrivx.xpath('.//BinderItem[@ID="0"]'), parent_document: root)
  end

  private

  def gather_documents(documents:, parent_node:, parent_document:)
    parent_node.xpath('./Children/BinderItem').each_with_index do |node, index|
      document = Document.new(node: node, parent_path: parent_document.path, position: index + 1)
      documents << document
      gather_documents(documents: documents, parent_node: node, parent_document: document)
    end
  end
end

class Listing
  def initialize(scrivener)
    @paths = scrivener.documents.map{ |document|
        path = document.path
        dir = path.dirname
        basename = path.basename
        "#{dir / basename}.html"
    }
  end

  def write_to(metadata_path:, content_dir:)
    metadata_path.mkpath
    listing_file = metadata_path / 'contents.yaml'
    content = StringIO.new
    @paths.each { |path| content.puts "- #{content_dir / path}" }
    listing_file.write(content.string)
  end

  private
end

options = CommandLine.parse
scrivener = Scrivener.new(options[:scrivener_file])

puts scrivener.documents.map { |document| document.header }

content_dir = Pathname.new 'content'
content_path = options[:book_dir] / content_dir
metadata_path = options[:book_dir] / '_data'

Listing.new(scrivener).write_to(metadata_path: metadata_path, content_dir: content_dir)
ScrivenerToMarkdown.new(scrivener).write_to(content_path)
